<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Home</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Home</h1>

    



    


    <h3> </h3>










    




    <section>
        <article><h1>Building Applications With Open MCT</h1><h2>Scope and purpose of this document</h2><p>This document is intended to serve as a reference for developing an application 
based on Open MCT. It will provide details of the API functions necessary to extend the 
Open MCT platform meet common use cases such as integrating with a telemetry source. </p>
<p>The best place to start is with the <a href="https://github.com/nasa/openmct-tutorial">Open MCT Tutorials</a>. 
These will walk you through the process of getting up and running with Open MCT, 
as well as addressing some common developer use cases.</p>
<h2>Building From Source</h2><p>The latest version of Open MCT is available from <a href="https://github.com/nasa/openmct">our GitHub repository</a>. 
If you have <code>git</code>, and <code>node</code> installed, you can build Open MCT with the commands </p>
<pre class="prettyprint source"><code>git clone https://github.com/nasa/openmct.git
cd openmct
npm install</code></pre><p>These commands will fetch the Open MCT source from our GitHub repository, and build 
a minified version that can be included in your application. The output of the 
build process is placed in a <code>dist</code> folder under the openmct source directory, 
which can be copied out to another location as needed. The contents of this 
folder will include a minified javascript file named <code>openmct.js</code> as well as 
assets such as html, css, and images necessary for the UI. </p>
<h2>Starting an Open MCT application</h2><p>To start a minimally functional Open MCT application, it is necessary to include 
the Open MCT distributable, enable some basic plugins, and bootstrap the application. 
The tutorials walk through the process of getting Open MCT up and running from scratch,
but provided below is a minimal HTML template that includes Open MCT, installs 
some basic plugins, and bootstraps the application. It assumes that Open MCT is 
installed under an <code>openmct</code> subdirectory, as described in <a href="#building-from-source">Building From Source</a>. </p>
<p>This approach includes openmct using a simple script tag, resulting in a global 
variable named <code>openmct</code>. This <code>openmct</code> object is used subsequently to make API 
calls. </p>
<p>Open MCT is packaged as a UMD (Universal Module Definition) module, so common 
script loaders are also supported.</p>
<pre class="prettyprint source lang-html"><code>&lt;!DOCTYPE html>
&lt;html>
&lt;head>
    &lt;title>Open MCT&lt;/title>
    &lt;script src=&quot;openmct.js&quot;>&lt;/script>
&lt;/head>
&lt;body>
    &lt;script>
        openmct.setAssetPath('openmct/dist');
        openmct.install(openmct.plugins.LocalStorage());
        openmct.install(openmct.plugins.MyItems());
        openmct.install(openmct.plugins.UTCTimeSystem());
        openmct.install(openmct.plugins.Espresso());
        openmct.start();
    &lt;/script>
&lt;/body>
&lt;/html></code></pre><p>The Open MCT library included above requires certain assets such as html templates, 
images, and css. If you installed Open MCT from GitHub as described in the section 
on <a href="#building-from-source">Building from Source</a> then these assets will have been 
downloaded along with the Open MCT javascript library. You can specify the 
location of these assets by calling <code>openmct.setAssetPath()</code>. Typically this will 
be the same location as the <code>openmct.js</code> library is included from.</p>
<p>There are some plugins bundled with the application that provide UI, persistence, 
and other default configuration which are necessary to be able to do anything with 
the application initially. Any of these plugins can, in principle, be replaced with a custom 
plugin. The included plugins are documented in the <a href="#included-plugins">Included Plugins</a> 
section.  </p>
<h2>Plugins</h2><h3>Defining and Installing a New Plugin</h3><pre class="prettyprint source lang-javascript"><code>openmct.install(function install(openmctAPI) {
    // Do things here
    // ...
});</code></pre><p>New plugins are installed in Open MCT by calling <code>openmct.install</code>, and providing 
a plugin installation function. This function will be invoked on application 
startup with one parameter - the openmct API object. A common approach used in 
the Open MCT codebase is to define a plugin as a function that returns this 
installation function. This allows configuration to be specified when the plugin is included.</p>
<p>eg.</p>
<pre class="prettyprint source lang-javascript"><code>openmct.install(openmct.plugins.Elasticsearch(&quot;http://localhost:8002/openmct&quot;));</code></pre><p>This approach can be seen in all of the <a href="https://github.com/nasa/openmct/blob/master/src/plugins/plugins.js">plugins provided with Open MCT</a>.</p>
<h2>Domain Objects and Identifiers</h2><p><em>Domain Objects</em> are the basic entities that represent domain knowledge in Open MCT.
The temperature sensor on a solar panel, an overlay plot comparing 
the results of all temperature sensors, the command dictionary for a spacecraft,
the individual commands in that dictionary, the &quot;My Items&quot; folder:
All of these things are domain objects.</p>
<p>A <em>Domain Object</em> is simply a javascript object with some standard attributes.<br>An example of a <em>Domain Object</em> is the &quot;My Items&quot; object which is a folder in 
which a user can persist any objects that they create. The My Items object 
looks like this: </p>
<pre class="prettyprint source lang-javascript"><code>{
    identifier: {
        namespace: &quot;&quot;
        key: &quot;mine&quot;
    }
    name:&quot;My Items&quot;,
    type:&quot;folder&quot;,
    location:&quot;ROOT&quot;,
    composition: []
}</code></pre><h3>Object Attributes</h3><p>The main attributes to note are the <code>identifier</code>, and <code>type</code> attributes.</p>
<ul>
<li><code>identifier</code>: A composite key that provides a universally unique identifier for 
this object. The <code>namespace</code> and <code>key</code> are used to identify the object. The <code>key</code> 
must be unique within the namespace. </li>
<li><code>type</code>: All objects in Open MCT have a type. Types allow you to form an 
ontology of knowledge and provide an abstraction for grouping, visualizing, and 
interpreting data. Details on how to define a new object type are provided below. </li>
</ul>
<p>Open MCT uses a number of builtin types. Typically you are going to want to 
define your own if extending Open MCT.</p>
<h3>Domain Object Types</h3><p>Custom types may be registered via the <code>addType</code> function on the opencmt Type 
registry.</p>
<p>eg.</p>
<pre class="prettyprint source lang-javascript"><code>openmct.types.addType('my-type', {
    label: &quot;My Type&quot;,
    description: &quot;This is a type that I added!&quot;,
    creatable: true
});</code></pre><p>The <code>addType</code> function accepts two arguments:</p>
<ul>
<li>A <code>string</code> key identifying the type. This key is used when specifying a type 
for an object.</li>
<li>An object type specification. An object type definition supports the following 
attributes      <ul>
<li><code>label</code>: a <code>string</code> naming this object type</li>
<li><code>description</code>: a <code>string</code> specifying a longer-form description of this type</li>
<li><code>initialize</code>: a <code>function</code> which initializes the model for new domain objects 
of this type. This can be used for setting default values on an object when 
it is instantiated.</li>
<li><code>creatable</code>: A <code>boolean</code> indicating whether users should be allowed to create 
this type (default: <code>false</code>). This will determine whether the type appears 
in the <code>Create</code> menu.</li>
<li><code>cssClass</code>: A <code>string</code> specifying a CSS class to apply to each representation 
of this object. This is used for specifying an icon to appear next to each 
object of this type.</li>
</ul>
</li>
</ul>
<p>The <a href="https://github.com/openmct/openmct-tutorial">Open MCT Tutorials</a> provide a 
step-by-step examples of writing code for Open MCT that includes a <a href="https://github.com/nasa/openmct-tutorial#step-3---providing-objects">section on 
defining a new object type</a>.</p>
<h2>Root Objects</h2><p>In many cases, you'd like a certain object (or a certain hierarchy of objects) 
to be accessible from the top level of the application (the tree on the left-hand 
side of Open MCT.) For example, it is typical to expose a telemetry dictionary 
as a hierarchy of telemetry-providing domain objects in this fashion.</p>
<p>To do so, use the <code>addRoot</code> method of the object API.</p>
<p>eg.</p>
<pre class="prettyprint source lang-javascript"><code>openmct.objects.addRoot({
        namespace: &quot;my-namespace&quot;,
        key: &quot;my-key&quot;
    });</code></pre><p>The <code>addRoot</code> function takes a single <a href="#domain-objects-and-identifiers">object identifier</a> 
as an argument. </p>
<p>Root objects are loaded just like any other objects, i.e. via an object
provider.</p>
<h2>Object Providers</h2><p>An Object Provider is used to build <em>Domain Objects</em>, typically retrieved from 
some source such as a persistence store or telemetry dictionary. In order to 
integrate telemetry from a new source an object provider will need to be created 
that can build objects representing telemetry points exposed by the telemetry 
source. The API call to define a new object provider is fairly straightforward. 
Here's a very simple example:</p>
<pre class="prettyprint source lang-javascript"><code>openmct.objects.addProvider('example.namespace', {
    get: function (identifier) {
        return Promise.resolve({
            identifier: identifier,
            name: 'Example Object',
            type: 'example-object-type'
        });
    }
});</code></pre><p>The <code>addProvider</code> function takes two arguments:</p>
<ul>
<li><code>namespace</code>: A <code>string</code> representing the namespace that this object provider 
will provide objects for.</li>
<li><code>provider</code>: An <code>object</code> with a single function, <code>get</code>. This function accepts an 
<a href="#domain-objects-and-identifiers">Identifier</a> for the object to be provided. 
It is expected that the <code>get</code> function will return a 
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> 
that resolves with the object being requested.</li>
</ul>
<p>In future, object providers will support other methods to enable other operations 
with persistence stores, such as creating, updating, and deleting objects.</p>
<h2>Composition Providers</h2><p>The <em>composition</em> of a domain object is the list of objects it contains, as shown 
(for example) in the tree for browsing. Open MCT provides a
<a href="#default-composition-provider">default solution</a> for composition, but there
may be cases where you want to provide the composition of a certain object
(or type of object) dynamically.</p>
<h3>Adding Composition Providers</h3><p>You may want to populate a hierarchy under a custom root-level object based on 
the contents of a telemetry dictionary. To do this, you can add a new 
Composition Provider:</p>
<pre class="prettyprint source lang-javascript"><code>openmct.composition.addProvider({
    appliesTo: function (domainObject) {
        return domainObject.type === 'my-type';
    },
    load: function (domainObject) {
        return Promise.resolve(myDomainObjects);
    }
});</code></pre><p>The <code>addProvider</code> function accepts a Composition Provider object as its sole 
argument. A Composition Provider is a javascript object exposing two functions:</p>
<ul>
<li><code>appliesTo</code>: A <code>function</code> that accepts a <code>domainObject</code> argument, and returns 
a <code>boolean</code> value indicating whether this composition provider applies to the 
given object.</li>
<li><code>load</code>: A <code>function</code> that accepts a <code>domainObject</code> as an argument, and returns
a <code>Promise</code> that resolves with an array of <a href="#domain-objects-and-identifiers">Identifier</a>.
These identifiers will be used to fetch Domain Objects from an <a href="#object-provider">Object Provider</a></li>
</ul>
<h3>Default Composition Provider</h3><p>The default composition provider applies to any domain object with a <code>composition</code> 
property. The value of <code>composition</code> should be an array of identifiers, e.g.:</p>
<pre class="prettyprint source lang-javascript"><code>var domainObject = {
    name: &quot;My Object&quot;,
    type: 'folder',
    composition: [
        {
            id: '412229c3-922c-444b-8624-736d85516247',
            namespace: 'foo'
        },
        {
            key: 'd6e0ce02-5b85-4e55-8006-a8a505b64c75',
            namespace: 'foo'
        }
    ]
};</code></pre><h2>Telemetry Providers</h2><p>When connecting to a new telemetry source, you will need to register a new
<em>Telemetry Provider</em>. A <em>Telemetry Provider</em> retrieves telemetry data from some telemetry 
source, and exposes them in a way that can be used by Open MCT. A telemetry 
provider typically can support a one off <strong>request</strong> for a batch of telemetry data, 
or it can provide the ability to <strong>subscribe</strong> to receive new telemetry data when 
it becomes available, or both.</p>
<pre class="prettyprint source lang-javascript"><code>openmct.telemetry.addProvider({
    supportsRequest: function (domainObject) {
        //...
    },
    supportsSubscribe: function (domainObject) {
        //...
    },
    request: function (domainObject, options) {    
        //...
    },
    subscribe: function (domainObject, callback, options) {
        //...
    }
})</code></pre><p>A telemetry provider is an object with the following functions defined:</p>
<ul>
<li><code>supportsRequest</code>: An <strong>optional</strong> <code>function</code> that accepts a 
<a href="#domain-objects-and-identifiers">Domain Object</a> and returns a <code>boolean</code> value
indicating whether or not this provider supports telemetry requests for the 
given object. If this returns <code>true</code> then a <code>request</code> function must be defined. </li>
<li><code>supportsSubscribe</code>: An <strong>optional</strong> <code>function</code> that accepts a 
<a href="#domain-objects-and-identifiers">Domain Object</a> and returns a <code>boolean</code> value 
indicating whether or not this provider supports telemetry subscriptions. If this 
returns <code>true</code> then a <code>subscribe</code> function must also be defined. As with <code>request</code>, 
the return value will typically be conditional, and based on attributes of 
<code>domainObject</code> such as its identifier.</li>
<li><code>request</code>: A <code>function</code> that returns a <code>Promise</code> that will resolve with an <code>Array</code> 
of telemetry in a single query. This function accepts as arguments a 
<a href="#domain-objects-and-identifiers">Domain Object</a> and an object containing some 
<a href="#telemetry-requests">request options</a>. </li>
<li><code>subscribe</code>:  A <code>function</code> that accepts a <a href="#domain-objects-and-identifiers">Domain Object</a>,
a callback <code>function</code>, and a <a href="#telemetry-requests">telemetry request</a>. The 
callback is invoked whenever telemetry is available, and </li>
</ul>
<p>The implementations for <code>request</code> and <code>subscribe</code> can vary depending on the
nature of the endpoint which will provide telemetry. In the example above,
it is assumed that <code>myAdapter</code> contains the implementation details
(such as HTTP requests, WebSocket connections, etc.) associated with some telemetry
source.</p>
<p>For a step-by-step guide to building a telemetry adapter, please see the 
<a href="https://github.com/larkin/openmct-tutorial">Open MCT Tutorials</a>.</p>
<h3>Telemetry Requests</h3><p>Telemetry requests support time bounded queries. A call to a <em>Telemetry Provider</em>'s 
<code>request</code> function will include an <code>options</code> argument. These are simply javascript
objects with attributes for the request parameters. An example of a telemetry 
request object with a start and end time is included below:</p>
<pre class="prettyprint source lang-javascript"><code>{
    start: 1487981997240,
    end: 1487982897240
}</code></pre><h3>Telemetry Formats</h3><p>Telemetry format objects define how to interpret and display telemetry data. 
They have a simple structure:</p>
<ul>
<li><code>key</code>: A <code>string</code> that uniquely identifies this formatter.</li>
<li><code>format</code>: A <code>function</code> that takes a raw telemetry value, and returns a human-readable
<code>string</code> representation of that value. It has one required argument, and three 
optional arguments that provide context and can be used for returning scaled 
representations of a value. An example of this is representing time values in a 
scale such as the time conductor scale. There are multiple ways of representing 
a point in time, and by providing a minimum scale value, maximum scale value, 
and a count, it's possible to provide more useful representations of time given 
the provided limitations.  <ul>
<li><code>value</code>: The raw telemetry value in its native type.</li>
<li><code>minValue</code>: An <strong>optional</strong> argument specifying the minimum displayed value.</li>
<li><code>maxValue</code>: An <strong>optional</strong> argument specifying the maximum displayed value.</li>
<li><code>count</code>: An <strong>optional</strong> argument specifying the number of displayed values.</li>
</ul>
</li>
<li><code>parse</code>: A <code>function</code> that takes a <code>string</code> representation of a telemetry value,
and returns the value in its native type. It accepts one argument:<ul>
<li><code>text</code>: A <code>string</code> representation of a telemetry value.</li>
</ul>
</li>
<li><code>validate</code>: A <code>function</code> that takes a <code>string</code> representation of a telemetry 
value, and returns a <code>boolean</code> value indicating whether the provided string can be 
parsed.</li>
</ul>
<h4>Registering Formats</h4><p>Formats are registered with the Telemetry API using the <code>addFormat</code> function. eg.</p>
<pre class="prettyprint source lang-javascript"><code>openmct.telemetry.addFormat({
    key: 'number-to-string',
    format: function (number) {
        return number + '';
    },
    parse: function (text) {
        return Number(text);
    },
    validate: function (text) {
        return !isNaN(text);
    }
});</code></pre><h4>Examples of Formats in Use</h4><ul>
<li>The <a href="https://github.com/nasa/openmct/blob/time-api-redo/platform/features/conductor/core/src/ui/NumberFormat.js">NumberFormat</a><br>provides an example of a simple format available by default 
in OpenMCT.</li>
<li>The <a href="https://github.com/nasa/openmct/blob/master/src/plugins/utcTimeSystem/UTCTimeFormat.js">UTCTimeFormat</a> 
is a more complex implementation of a format that uses the optional context 
arguments in <code>format</code> to provide scale-appropriate values. </li>
</ul>
<h3>Telemetry Data</h3><p>Telemetry data is provided to Open MCT by <em><a href="#telemetry-providers">Telemetry Providers</a></em>
in the form of javascript objects. A collection of telemetry values (for example, 
retrieved in response to a <code>request</code>) is represented by an <code>Array</code> of javascript 
objects. These telemetry javascript objects are simply key value pairs.</p>
<p>Typically a telemetry datum will have some timestamp associated with it. This 
time stamp should have a key that corresponds to some time system supported by 
Open MCT. If the <code>UTCTimeSystem</code> plugin is installed, then the key <code>utc</code> can be used.</p>
<p>An example of a telemetry provider request function that returns a collection of
mock telemtry data is below:</p>
<pre class="prettyprint source lang-javascript"><code>openmct.telemetry.addProvider({
    supportsRequest: function (domainObject) {
        return true
    },
    request: function (domainObject, options) {    
        return Promise.resolve([
            {
                'utc': Date.now() - 2000,
                'value': 1,
            },
            {
                'utc': Date.now() - 1000,
                'value': 2,
            },
            {
                'utc': Date.now(),
                'value': 3,
            }
        ]);
    }
})</code></pre><h2>Time API</h2><p>Open MCT provides API for managing the temporal state of the application. Central 
to this is the concept of &quot;time bounds&quot;. Views in Open MCT will typically show 
telemetry data for some prescribed date range, and the Time API provides a way 
to centrally manage these bounds.</p>
<p>The Time API exposes a number of methods for querying and setting the temporal 
state of the application, and emits events to inform listeners when the state changes.</p>
<p>Because the data displayed tends to be time domain data, Open MCT must always 
have at least one time system installed and activated. When you download Open MCT,
it will be pre-configured to use the UTC time system, which is installed and 
activated, along with other default plugins, in <code>index.html</code>. Installing and 
activating a time system is simple, and is covered 
<a href="#defining-and-registering-time-systems">in the next section</a>. </p>
<h3>Time Systems and Bounds</h3><h4>Defining and Registering Time Systems</h4><p>The time bounds of an Open MCT application are defined as numbers, and a Time 
System gives meaning and context to these numbers so that they can be correctly 
interpreted. Time Systems are javscript objects that provide some information 
about the current time reference frame. An example of defining and registering 
a new time system is given below:</p>
<pre class="prettyprint source lang-javascript"><code>openmct.time.addTimeSystem({
    key: 'utc',
    name: 'UTC Time',
    cssClass = 'icon-clock',
    timeFormat = 'utc',
    durationFormat = 'duration',
    isUTCBased = true
});</code></pre><p>The example above defines a new utc based time system. In fact, this time system 
is configured and activated by default from <code>index.html</code> in the default 
installation of Open MCT if you download the source from GitHub. Some details of 
each of the required properties is provided below.</p>
<ul>
<li><code>key</code>: A <code>string</code> that uniquely identifies this time system.</li>
<li><code>name</code>: A <code>string</code> providing a brief human readable label. If the <a href="#the-time-conductor">Time Conductor</a> 
plugin is enabled, this name will identify the time system in a dropdown menu.</li>
<li><code>cssClass</code>: A class name <code>string</code> that will be applied to the time system when 
it appears in the UI. This will be used to represent the time system with an icon. 
There are a number of built-in icon classes <a href="https://github.com/nasa/openmct/blob/master/platform/commonUI/general/res/sass/_glyphs.scss">available in Open MCT</a>, 
or a custom class can be used here. </li>
<li><code>timeFormat</code>: A <code>string</code> corresponding to the key of a registered 
<a href="#telemetry-formats">telemetry time format</a>. The format will be used for 
displaying discrete timestamps from telemetry streams when this time system is 
activated. If the <a href="#included-plugins">UTCTimeSystem</a> is enabled, then the <code>utc</code> 
format can be used if this is a utc-based time system</li>
<li><code>durationFormat</code>: A <code>string</code> corresponding to the key of a registered 
<a href="#telemetry-formats">telemetry time format</a>. The format will be used for 
displaying time ranges, for example <code>00:15:00</code> might be used to represent a time 
period of fifteen minutes. These are used by the Time Conductor plugin to specify
relative time offsets. If the <a href="#included-plugins">UTCTimeSystem</a> is enabled, 
then the <code>duration</code> format can be used if this is a utc-based time system</li>
<li><code>isUTCBased</code>: A <code>boolean</code> that defines whether this time system represents 
numbers in UTC terrestrial time. </li>
</ul>
<h4>Getting and Setting the Active Time System</h4><p>Once registered, a time system can be activated using a key, or an instance of 
the time system itself.</p>
<pre class="prettyprint source lang-javascript"><code>openmct.time.timeSystem('utc');</code></pre><p>A time system can be immediately activated upon registration: </p>
<pre class="prettyprint source lang-javascript"><code>var utcTimeSystem = {
    key: 'utc',
    name: 'UTC Time',
    cssClass = 'icon-clock',
    timeFormat = 'utc',
    durationFormat = 'duration',
    isUTCBased = true
};
openmct.time.addTimeSystem(utcTimeSystem);
openmct.time.timeSystem(utcTimeSystem);</code></pre><p>Setting the active time system will trigger a <a href="#time-events">time system event</a>. </p>
<h3>Time Bounds</h3><p>The TimeAPI provides a getter/setter for querying and setting time bounds. Time 
bounds are simply an object with a <code>start</code> and an end <code>end</code> attribute.</p>
<ul>
<li><code>start</code>: A <code>number</code> representing a moment in time in the active <a href="#defining-and-registering-time-systems">Time System</a>. 
This will be used as the beginning of the time period displayed by time-responsive
telemetry views.</li>
<li><code>end</code>: A <code>number</code> representing a moment in time in the active <a href="#defining-and-registering-time-systems">Time System</a>.
This will be used as the end of the time period displayed by time-responsive
telemetry views.</li>
</ul>
<p>If invoked with bounds, it will set the new time bounds system-wide. If invoked 
without any parameters, it will return the current application-wide time bounds. </p>
<pre class="prettyprint source lang-javascript"><code>const ONE_HOUR = 60 * 60 * 1000;
let now = Date.now();
openmct.time.bounds({start: now - ONE_HOUR, now);</code></pre><p>To respond to bounds change events, simply register a callback against the <code>bounds</code>
event. For more information on the bounds event, please see the section on <a href="#time-events">Time Events</a>.</p>
<h2>Clocks</h2><p>The Time API can be set to follow a clock source which will cause the bounds
to be updated automatically whenever the clock source &quot;ticks&quot;. A clock is simply
an object that supports registration of listeners and periodically invokes its 
listeners with a number. Open MCT supports registration of new clock sources that 
tick on almost anything. A tick occurs when the clock invokes callback functions 
registered by its listeners with a new time value.</p>
<p>An example of a clock source is the <a href="https://github.com/nasa/openmct/blob/master/src/plugins/utcTimeSystem/LocalClock.js">LocalClock</a> 
which emits the current time in UTC every 100ms. Clocks can tick on anything. For 
example, a clock could be defined to provide the timestamp of any new data 
received via a telemetry subscription. This would have the effect of advancing 
the bounds of views automatically whenever data is received. A clock could also 
be defined to tick on some remote timing source.</p>
<p>The values provided by clocks are simple <code>number</code>s, which are interpreted in the
context of the active <a href="#defining-and-registering-time-systems">Time System</a>.</p>
<h3>Defining and registering clocks</h3><p>A clock is an object that defines certain required metadata and functions:</p>
<ul>
<li><code>key</code>: A <code>string</code> uniquely identifying this clock. This can be used later to 
reference the clock in places such as the <a href="#time-conductor-configuration">Time Conductor configuration</a></li>
<li><code>cssClass</code>: A <code>string</code> identifying a CSS class to apply to this clock when it's 
displayed in the UI. This will be used to represent the time system with an icon. 
There are a number of built-in icon classes <a href="https://github.com/nasa/openmct/blob/master/platform/commonUI/general/res/sass/_glyphs.scss">available in Open MCT</a>, 
or a custom class can be used here. </li>
<li><code>name</code>: A <code>string</code> providing a human-readable identifier for the clock source. 
This will be displayed in the clock selector menu in the Time Conductor UI 
component, if active. </li>
<li><code>description</code>: An <strong>optional</strong> <code>string</code> providing a longer description of the 
clock. The description will be visible in the clock selection menu in the Time 
Conductor plugin.</li>
<li><code>on</code>: A <code>function</code> supporting registration of a new callback that will be 
invoked when the clock next ticks. It will be invoked with two arguments:<ul>
<li><code>eventName</code>: A <code>string</code> specifying the event to listen on. For now, clocks 
support one event - <code>tick</code>.</li>
<li><code>callback</code>: A <code>function</code> that will be invoked when this clock ticks. The 
function must be invoked with one parameter - a <code>number</code> representing a valid
time in the current time system.</li>
</ul>
</li>
<li><code>off</code>: A <code>function</code> that allows deregistration of a tick listener. It accepts 
the same arguments as <code>on</code>.</li>
<li><code>currentValue</code>: A <code>function</code> that returns a <code>number</code> representing a point in 
time in the active time system. It should be the last value provided by a tick, 
or some default value if no ticking has yet occurred.</li>
</ul>
<p>A new clock can be registered using the <code>addClock</code> function exposed by the Time 
API:</p>
<pre class="prettyprint source lang-javascript"><code>var someClock = {
    key: 'someClock',
    cssClass: 'icon-clock',
    name: 'Some clock',
    description: &quot;Presumably does something useful&quot;,
    on: function (event, callback) {
        // Some function that registers listeners, and updates them on a tick
    },
    off: function (event, callback) {
        // Some function that unregisters listeners.
    },
    currentValue: function () {
        // A function that returns the last ticked value for the clock
    }
}

openmct.time.addClock(someClock);</code></pre><p>An example clock implementation is provided in the form of the <a href="https://github.com/nasa/openmct/blob/master/src/plugins/utcTimeSystem/LocalClock.js">LocalClock</a></p>
<h4>Getting and setting active clock</h4><p>Once registered a clock can be activated by calling the <code>clock</code> function on the 
Time API passing in the key or instance of a registered clock. Only one clock 
may be active at once, so activating a clock will deactivate any currently 
active clock. Setting the clock will also trigger a <a href="#time-events">'clock' event</a>.</p>
<pre class="prettyprint source"><code>openmct.time.clock(someClock);</code></pre><p>Upon being activated, a clock's <code>on</code> function will be immediately called to subscribe
to <code>tick</code> events.</p>
<p>The currently active clock (if any) can be retrieved by calling the same 
function without any arguments.</p>
<h4>Stopping an active clock</h4><p>The <code>stopClock</code> method can be used to stop an active clock, and to clear it. It 
will stop the clock from ticking, and set the active clock to <code>undefined</code>.</p>
<pre class="prettyprint source lang-javascript"><code>openmct.time.stopClock();</code></pre><h4>Clock Offsets</h4><p>When a clock is active, the time bounds of the application will be updated 
automatically each time the clock &quot;ticks&quot;. The bounds are calculated based on 
the current value provided by the active clock (via its <code>tick</code> event, or its 
<code>currentValue()</code> method). </p>
<p>Unlike bounds, which represent absolute time values, clock offsets represent
relative time spans. Offsets are defined as an object with two properties:</p>
<ul>
<li><code>start</code>: A <code>number</code> that must be &lt; 0 and which is used to calculate the start 
bounds on each clock tick. The start offset will be calculated relative to the 
value provided by a clock's tick callback, or its <code>currentValue()</code> function.</li>
<li><code>end</code>: A <code>number</code> that must be &gt;=0 and which is used to calculate the end 
bounds on each clock tick.</li>
</ul>
<p>The <code>clockOffsets</code> function can be used to get or set clock offsets. For example, 
to show the last fifteen minutes in a ms-based time system: </p>
<pre class="prettyprint source lang-javascript"><code>var FIFTEEN_MINUTES = 15 * 60 * 1000;

openmct.time.clockOffsets({
    start: -FIFTEEN_MINUTES,
    end: 0
})</code></pre><p><strong>Note:</strong> Setting the clock offsets will trigger an immediate bounds change, as 
new bounds will be calculated based on the <code>currentValue()</code> of the active clock. 
Clock offsets are only relevant when a clock source is active.</p>
<h2>Time Events</h2><p>The time API supports the registration of listeners that will be invoked when the 
application's temporal state changes. Events listeners can be registered using 
the <code>on</code> function. They can be deregistered using the <code>off</code> function. The arguments
accepted by the <code>on</code> and <code>off</code> functions are:</p>
<ul>
<li><code>event</code>: A <code>string</code> naming the event to subscribe to. Event names correspond to
the property of the Time API you're interested in. A <a href="#list-of-time-events">full list of time events</a> 
is provided later.</li>
</ul>
<p>As an example, the code to listen to bounds change events looks like:</p>
<pre class="prettyprint source lang-javascript"><code>openmct.time.on('bounds', function callback (newBounds, tick) {
    // Do something with new bounds
});</code></pre><h4>List of Time Events</h4><p>The events supported by the Time API are:</p>
<ul>
<li><code>bounds</code>: Listen for changes to current bounds. The callback will be invoked 
with two arguments:<ul>
<li><code>bounds</code>: A <a href="#getting-and-setting-bounds">bounds</a> bounds object representing 
a new time period bound by the specified start and send times.</li>
<li><code>tick</code>: A <code>boolean</code> indicating whether or not this bounds change is due to a 
&quot;tick&quot; from a <a href="#clocks">clock source</a>. This information can be useful when 
determining a strategy for fetching telemetry data in response to a bounds 
change event. For example, if the bounds change was automatic, and is due 
to a tick then it's unlikely that you would need to perform a historical 
data query. It should be sufficient to just show any new telemetry received 
via subscription since the last tick, and optionally to discard any older 
data that now falls outside of the currently set bounds. If <code>tick</code> is false,
then the bounds change was not due to an automatic tick, and a query for 
historical data may be necessary, depending on your data caching strategy, 
and how significantly the start bound has changed.</li>
</ul>
</li>
<li><code>timeSystem</code>: Listen for changes to the active <a href="#defining-and-registering-time-systems">time system</a>.
The callback will be invoked with a single argument - the newly active time system.<ul>
<li><code>timeSystem</code>: The newly active <a href="#defining-and-registering-time-systems">time system</a> object.</li>
</ul>
</li>
<li><code>clock</code>: Listen for changes to the active clock. When invoked, the callback 
will be provided with the new clock.<ul>
<li><code>clock</code>: The newly active <a href="#clocks">clock</a>, or <code>undefined</code> if an active clock
has been deactivated.</li>
</ul>
</li>
<li><code>clockOffsets</code>: Listen for changes to active clock offsets. When invoked the 
callback will be provided with the new clock offsets.<ul>
<li><code>clockOffsets</code>: A <a href="#clock-offsets">clock offsets</a> object.</li>
</ul>
</li>
</ul>
<h2>The Time Conductor</h2><p>The Time Conductor provides a user interface for managing time bounds in Open MCT.
It allows a user to select from configured time systems and clocks, and to set bounds
and clock offsets.</p>
<p>If activated, the time conductor must be provided with configuration options, 
detailed below.</p>
<h4>Time Conductor Configuration</h4><p>The time conductor is configured by specifying the options that will be 
available to the user from the menus in the time conductor. These will determine 
the clocks available from the conductor, the time systems available for each 
clock, and some default bounds and clock offsets for each combination of clock 
and time system. By default, the conductor always supports a <code>fixed</code> mode where 
no clock is active. To specify configuration for fixed mode, simply leave out a
<code>clock</code> attribute in the configuration entry object.</p>
<p>Configuration is provided as an <code>array</code> of menu options. Each entry of the 
array is an object with some properties specifying configuration. The configuration
options specified are slightly different depending on whether or not it is for 
an active clock mode.</p>
<p><strong>Configuration for Fixed Time Mode (no active clock)</strong></p>
<ul>
<li><code>timeSystem</code>: A <code>string</code>, the key for the time system that this configuration 
relates to.</li>
<li><code>bounds</code>: A <a href="#time-bounds"><code>Time Bounds</code></a> object. These bounds will be applied 
when the user selects the time system specified in the previous <code>timeSystem</code> 
property.</li>
<li><code>zoomOutLimit</code>: An <strong>optional</strong> <code>number</code> specifying the longest period of time 
that can be represented by the conductor when zooming. If a <code>zoomOutLimit</code> is 
provided, then a <code>zoomInLimit</code> must also be provided. If provided, the zoom 
slider will automatically become available in the Time Conductor UI.</li>
<li><code>zoomInLimit</code>: An <strong>optional</strong> <code>number</code> specifying the shortest period of time 
that can be represented by the conductor when zooming. If a <code>zoomInLimit</code> is 
provided, then a <code>zoomOutLimit</code> must also be provided. If provided, the zoom 
slider will automatically become available in the Time Conductor UI.</li>
</ul>
<p><strong>Configuration for Active Clock</strong></p>
<ul>
<li><code>clock</code>: A <code>string</code>, the <code>key</code> of the clock that this configuration applies to. </li>
<li><code>timeSystem</code>: A <code>string</code>, the key for the time system that this configuration 
relates to. Separate configuration must be provided for each time system that you 
wish to be available to users when they select the specified clock.</li>
<li><code>clockOffsets</code>: A <a href="#clock-offsets"><code>clockOffsets</code></a> object that will be 
automatically applied when the combination of clock and time system specified in 
this configuration is selected from the UI.</li>
</ul>
<h4>Example conductor configuration</h4><p>An example time conductor configuration is provided below. It sets up some 
default options for the <a href="https://github.com/nasa/openmct/blob/master/src/plugins/utcTimeSystem/UTCTimeSystem.js">UTCTimeSystem</a> 
and <a href="https://github.com/nasa/openmct/blob/master/src/plugins/localTimeSystem/LocalTimeSystem.js">LocalTimeSystem</a>, 
in both fixed mode, and for the <a href="https://github.com/nasa/openmct/blob/master/src/plugins/utcTimeSystem/LocalClock.js">LocalClock</a> 
source. In this configutation, the local clock supports both the UTCTimeSystem 
and LocalTimeSystem. Configuration for fixed bounds mode is specified by omitting 
a clock key.</p>
<pre class="prettyprint source lang-javascript"><code>const ONE_YEAR = 365 * 24 * 60 * 60 * 1000;
const ONE_MINUTE = 60 * 1000;

openmct.install(openmct.plugins.Conductor({
    menuOptions: [
        // 'Fixed' bounds mode configuation for the UTCTimeSystem
        {
            timeSystem: 'utc',
            bounds: {start: Date.now() - 30 * ONE_MINUTE, end: Date.now()},
            zoomOutLimit: ONE_YEAR,
            zoomInLimit: ONE_MINUTE
        },
        // Configuration for the LocalClock in the UTC time system
        {
            clock: 'local',
            timeSystem: 'utc',
            clockOffsets: {start: - 30 * ONE_MINUTE, end: 0},
            zoomOutLimit: ONE_YEAR,
            zoomInLimit: ONE_MINUTE
        },
        //Configuration for the LocaLClock in the Local time system
        {
            clock: 'local',
            timeSystem: 'local',
            clockOffsets: {start: - 15 * ONE_MINUTE, end: 0}
        }
    ]
}));</code></pre><h2>Included Plugins</h2><p>Open MCT is packaged along with a few general-purpose plugins:</p>
<ul>
<li><code>openmct.plugins.Conductor</code> provides a user interface for working with time
within the application. If activated, configuration must be provided. This is 
detailed in the section on <a href="#time-conductor-configuration">Time Conductor Configuration</a>.</li>
<li><code>openmct.plugins.CouchDB</code> is an adapter for using CouchDB for persistence
of user-created objects. This is a constructor that takes the URL for the
CouchDB database as a parameter, e.g.<pre class="prettyprint source lang-javascript"><code>openmct.install(openmct.plugins.CouchDB('http://localhost:5984/openmct'))</code></pre></li>
<li><code>openmct.plugins.Elasticsearch</code> is an adapter for using Elasticsearch for
persistence of user-created objects. This is a
constructor that takes the URL for the Elasticsearch instance as a
parameter. eg.<pre class="prettyprint source lang-javascript"><code>openmct.install(openmct.plugins.CouchDB('http://localhost:9200'))</code></pre></li>
<li><code>openmct.plugins.Espresso</code> and <code>openmct.plugins.Snow</code> are two different
themes (dark and light) available for Open MCT. Note that at least one
of these themes must be installed for Open MCT to appear correctly.</li>
<li><code>openmct.plugins.LocalStorage</code> provides persistence of user-created
objects in browser-local storage. This is particularly useful in
development environments.</li>
<li><code>openmct.plugins.MyItems</code> adds a top-level folder named &quot;My Items&quot;
when the application is first started, providing a place for a
user to store created items.</li>
<li><code>openmct.plugins.UTCTimeSystem</code> provides a default time system for Open MCT.</li>
</ul>
<p>Generally, you will want to either install these plugins, or install
different plugins that provide persistence and an initial folder
hierarchy.</p>
<p>eg.</p>
<pre class="prettyprint source lang-javascript"><code>openmct.install(openmct.plugins.LocalStorage());
openmct.install(openmct.plugins.MyItems());</code></pre></article>
    </section>






</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module-openmct.Dialog.html">Dialog</a></li><li><a href="module-openmct.MCT.html">MCT</a></li><li><a href="module-openmct.Type.html">Type</a></li><li><a href="platform_commonUI_formats.DurationFormat.html">DurationFormat</a></li><li><a href="platform_commonUI_formats.LocalTimeFormat.html">LocalTimeFormat</a></li><li><a href="platform_commonUI_formats.UTCTimeFormat.html">UTCTimeFormat</a></li></ul><h3>Events</h3><ul><li><a href="module-openmct.MCT.html#~event:start">start</a></li><li><a href="module-openmct.TimeAPI.html#~event:bounds">bounds</a></li><li><a href="module-openmct.TimeAPI.html#~event:clock">clock</a></li><li><a href="module-openmct.TimeAPI.html#~event:clockOffsets">clockOffsets</a></li><li><a href="module-openmct.TimeAPI.html#~event:timeOfInterest">timeOfInterest</a></li><li><a href="module-openmct.TimeAPI.html#~event:timeSystem">timeSystem</a></li></ul><h3>Interfaces</h3><ul><li><a href="module-openmct.CompositionAPI.html">CompositionAPI</a></li><li><a href="module-openmct.CompositionCollection.html">CompositionCollection</a></li><li><a href="module-openmct.CompositionProvider.html">CompositionProvider</a></li><li><a href="module-openmct.GestureAPI.html">GestureAPI</a></li><li><a href="module-openmct.ObjectAPI.html">ObjectAPI</a></li><li><a href="module-openmct.ObjectProvider.html">ObjectProvider</a></li><li><a href="module-openmct.TelemetryAPI.html">TelemetryAPI</a></li><li><a href="module-openmct.TelemetryAPI-LimitEvaluator.html">LimitEvaluator</a></li><li><a href="module-openmct.TelemetryAPI-TelemetryFormatter.html">TelemetryFormatter</a></li><li><a href="module-openmct.TelemetryAPI-TelemetryProvider.html">TelemetryProvider</a></li><li><a href="module-openmct.TimeAPI.html">TimeAPI</a></li><li><a href="module-openmct.TypeRegistry.html">TypeRegistry</a></li><li><a href="module-openmct.View.html">View</a></li><li><a href="module-openmct.ViewProvider.html">ViewProvider</a></li><li><a href="module-openmct.ViewRegistry.html">ViewRegistry</a></li><li><a href="MutableObject.html">MutableObject</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Tue May 02 2017 19:05:52 GMT+0000 (UTC)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>